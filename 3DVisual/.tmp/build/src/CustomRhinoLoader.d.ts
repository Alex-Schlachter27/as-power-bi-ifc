export class CustomRhinoLoader extends Loader {
    constructor(manager: any);
    libraryPath: string;
    libraryPending: Promise<void>;
    libraryBinary: any;
    libraryConfig: {};
    url: string;
    workerLimit: number;
    workerPool: any[];
    workerNextTaskID: number;
    workerSourceURL: string;
    workerConfig: {};
    materials: any[];
    warnings: any[];
    setLibraryPath(path: any): CustomRhinoLoader;
    setWorkerLimit(workerLimit: any): CustomRhinoLoader;
    load(url: any, onLoad: any, onProgress: any, onError: any): void;
    debug(): void;
    decodeObjects(buffer: any, url: any): Promise<Object3D<import("three").Event>>;
    parse(data: any, onLoad: any, onError: any): void;
    _compareMaterials(material: any): any;
    _createMaterial(material: any): MeshStandardMaterial;
    _createGeometry(data: any): Object3D<import("three").Event>;
    _createObject(obj: any, mat: any): DirectionalLight | Points<import("three").BufferGeometry | import("three").InstancedBufferGeometry, any> | Mesh<import("three").BufferGeometry | import("three").InstancedBufferGeometry, any> | Line<import("three").BufferGeometry | import("three").InstancedBufferGeometry, any> | Sprite | PointLight | SpotLight | RectAreaLight;
    _initLibrary(): Promise<void>;
    _getWorker(taskCost: any): Promise<any>;
    _releaseTask(worker: any, taskID: any): void;
    dispose(): CustomRhinoLoader;
}
import { Loader } from "three/src/loaders/Loader";
import { Object3D } from "three/src/core/Object3D";
import { MeshStandardMaterial } from "three/src/materials/MeshStandardMaterial";
import { DirectionalLight } from "three/src/lights/DirectionalLight";
import { Points } from "three/src/objects/Points";
import { Mesh } from "three/src/objects/Mesh";
import { Line } from "three/src/objects/Line";
import { Sprite } from "three/src/objects/Sprite";
import { PointLight } from "three/src/lights/PointLight";
import { SpotLight } from "three/src/lights/SpotLight";
import { RectAreaLight } from "three/src/lights/RectAreaLight";
